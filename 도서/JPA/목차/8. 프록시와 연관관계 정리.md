
### 프록시

엔티티가 실제 사용될 때까지 DB 조회 지연이 되게 해준다.
-> 지연(Lazy) 로딩

> 지연 로딩 구현 방법을 JPA 구현체에 위임 - Hibernate 가 알아서 구현

`qgetReference` : 엔티티 실제 사용 시점까지 조회를 미룸
-> 접근을 위임 받은 프록시 객체 반환

실제 클래스 상속받아 구현되므로 사용 입장에서는 구분하지 않고 사용하면 된다

```java
Entity {
	long id;
	String name;
	getId();
	getName();
}
Proxy {
	Entity target;
	getId();
	getName();
}
```

#### 프록시 객체 초기화
프록시 객체 메소드 호출시? -> 실제 객체 메소드 호출
실제 사용될 떄 DB 조회해서 엔티티 객체 - 프록시 객체의 초기화

```java
Member member = em.getReference(Member.class,"id1");
member.getName();

======================================================

class MemberProxy extends Member{
	Member target = null;
	public String getName(){
		this.target = ...;
	}
	return target.getName();
}
```

target 을 주입할때
1. 초기화 요청
2. DB 조회
3. 실제 엔티티 생성&보관
의 단계를 거친다.

#### 특징

- 처음 사용할때 한번만 초기화
- 프록시 객체가 초기화 한다고, 실제 엔티티로 바뀌는 것은 아님 - 초기화 되어도, 프록시 객체 통해서 실제 엔티티 접근
- 영속 컨텍스트에 이미 찾는 엔티티가 있으면, `getRefernce` 호출해도 실제 엔티티 반환
( 확인 결과, 엔티티 매니저 내 있으면 받아옴 )

- 초기화는 영속성 컨텍스트 아래에서만 가능하다.
```java
postRepository.save(post);  
final var result = em.getReference(Post.class, 1);  
System.out.println(result);
```

result 는 영속 범위 밖이므로 불가능
-> `LazyInitializationException` 발생!

```java
try {
	newEm.getTransaction().begin();  // 트랜잭션 시작

	final var result = newEm.getReference(Post.class, post.getId());
	System.out.println(result);
	System.out.println(result instanceof Post);

	newEm.getTransaction().commit();  // 트랜잭션 커밋
} 
```

이와 같이 트랜잭션의 범주 즉, 엔티티매니저의 범주내에 있어야만 가능

#### 프록시와 식별자

프록시는 식별자 값은 가지고 있으므로, getId를 해도 프록시 호출하지 않는다!
```java
Teat team = em.getReference(Team.class, "team1");
team.getId() -> 초기화 X

member.setTeam(team);
```
연관관계 설정할때 유용하게 사용 가능 - 어차피 조회할 필요 없이 ID를 통해서만 하면 OK!

### 즉시 로딩과 지연 로딩

- 즉시 로딩 : 엔티티 조회 시 연관된 엔티티 함께 조회
- 지연 로딩 : 연관된 엔티티 실제 사용할 때 조회
	-> JPA 가 SQL 호출해서 엔티티 조회

#### 즉시 로딩
```java
public class Member {
	@ManyToOne(fetch = FetchType.EAGER) // - Default 타입이긴 하나, 드러내도록 명시
	@JoinColumn(...)
	private Team team;
}

em.find(Member.class,"member");
```
회원 조회시 팀도 함께 조회
-> JPA구현체는 즉시 로딩 최적화 위해 조인 쿼리 사용한다.

> @JoinColumn  nullable 여부에 따라 JOIN 전략이 달라진다.
> nullable true 일 시? -> 외부 조인(LEFT OUTER JOIN) - 팀에 소속되지 않은 멤버가 있을수도 있다고 판단
> nullable false 일 시? -> 내부 조인(INNER JOIN)
> @ManyToOne(fetch = FetchType.EAGER, optional = false) 로도 nullable false 명시 가능
#### 지연 로딩
```java
@ManyToOne(fetch = FetchType.LAZY) // - Default 타입이긴 하나, 드러내도록 명시
@JoinColumn(...)
private Team team;
```

Member 를 먼저 호출 후 Team 이 필요할때 호출한다

> 조회 대상이 이미 영속 컨텍스트에 있으면 프록시 객체 사용하지 않는다.
### 지연 로딩 활용

우선은
자주 사용되면 즉시 로딩 - 가끔 사용되면 지연 로딩을 맞춰나가자
#### 프록시와 컬렉션 래퍼

```java
Member member = em.find(Member.class,"member1");
List<Order> orders = member.getOrders();
```

하이버네이트는 엔티티 영속 상태 만들 때 
엔티티에 컬렉션을 추적&관리 목적으로 하이버네이트 제공 내장 컬렉션으로 변경한다
-> 컬렉션 래퍼! ( hibernate 는 PersistentBag )
```java
member.getOrders() -> 컬렉션 초기화 X
member.getOrders().get(0) -> 컬렉션 초기화 O (실제 DB 조회)
```
#### 기본 Fetch 전략

- @ManyToOne, @OneToOne : 즉시 로딩
- @OneToMany, @ManyToMany : 지연 로딩

연관된 엔티티가 하나면 즉시 로딩, 컬렉션이면 지연 로딩!
( 하나 정도면, 즉시 로딩해도 큰 문제 발생 X )

=> 모든 연관관계에 지연 로딩 사용 후, 완료 단계 및 실제 상황 보고 즉시 로딩의 최적화를 해나가도 OK
##### EAGER 주의점

- 컬렉션 하나 이상 즉시 로딩 X : 서로 다른 컬렉션 2개 이상 조인시? -> N`*`M 으로 너무 많은 데이터 & 성능 저하
- 컬렉션 즉시 로딩 항상 외부 조인 사용(⭐️) : 다대일 관계 ( 멤버 - 팀 )시?
	-> 회원 테이블에 외래 키에 Not null 조건시, 모든 회원은 팀에 소속되므로 INNER JOIN OK
	-> 팀 테이블은? 회원이 한명도 없는 팀을 내부 조인 시, 팀까지 조회되지 않는 문제 발생
=> 일대다 관계 즉시 로딩시에는 항상 외부 조인을 사용하자!

### 영속성 전이 : CASCADE

특정 엔티티 영속 상태 만들 때 연관된 엔티티도 함께 영속 상태 만들고 싶으면?
-> <span style="color:#00b0f0">영속성 전이</span> 사용하자!
( 부모 엔티티 저장 시, 자식 엔티티 함께 저장 )

- JPA는 엔티티 저장할 때, 연관 모든 엔티티는 영속 상태여야 함
	-> 자식 엔티티 각각 영속 상태로 만들어야 하는 번거로움 유발 

#### 전이 : 저장
```java
@OneToMany(mappedBy = "parrent", cascade = CascadeType.PERSIST)
private List<Child> children = new ArrayList<>();
```

```java
Paraent parent = new Parent();
Child child1 = new Child(parent);

parent.getChilldren().add(child);

em.persist(parent);
```

연관관계 매핑하는 것과 아무런 관련 X ( 같이 영속화하는 편리함 제공 )
- 삭제할때도 역시 가능

이때 parent 도 Child에 명시해줘야 하며
배열에도 child를 추가해야만 한다

추가하는 만큼 insert문 나감 ( Parent 1 + Child 1 )
#### 전이 : 삭제
```java
@OneToMany(mappedBy = "parrent", cascade = CascadeType.REMOVE)

em.remove(parent);
```

외래 키 제약조건을 고려해 자식 먼저 삭제후 부모 삭제
( 존재하는 자식만큼 삭제 - 이때 만약 EAGER가 아닌 LAZY 로 배열을 받아오면 - select,delete 각각 두번씩 나가게 된다 )

=> 저장, 삭제는 flush 호출할 때 ( persist, remove X ) 전이 발생한다.
### 고아 객체

연관관계 끊어진 자식 엔티티 자동 삭제 기능
-> 고아 객체 제거

부모 엔티티 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티는 자동으로 삭제

```java
parent.getChildren().remove(0); // 자식 엔티티 제거
```
->
```sql
DELETE FROM CHILD WHERE ID=?
```

=> 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제
- 삭제한 엔티티를 다른 곳에서 참조하면 문제 발생! ( `@OneToOne` , `@OneToMany` 에서만 사용 가능! )
- 개념적으로 부모 제거 시, 자식은 고아 -> 부모 제거시, 자식도 같이 제거 ( CascadeType.REMOVE 설정과 같음 )


