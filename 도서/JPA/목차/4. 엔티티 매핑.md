### Entity

- 테이블과 매핑할 클래스는 필수 붙여야 하는 어노테이션
- JPA 가 관리
- name 지정 안할시 그대로 사용 ( Member -> Member )
- 기본 생성자 필수 ( 파라미터 없는 public/proteceted 생성자 )
- 저장 필드에 final 불가능
### Table

- 엔티티와 매핑할 테이블 지정 ( 생략시 엔티티 이름 = 테이블 이름 )
#### 스키마 자동 생성
`spring.jpa.hibernate.ddl-auto=xxx` 을 통해 지정
- create : 기존 테이블 삭제 후 새로 생성 - DROP + CREATE
- create-drop : create 속성 추가로, 종료 시 생성 테이블 삭제 - DROP + CREATE + DROP
- update : 테이블 엔티티 매핑 정보 비교해 변경 사항만 수정
- validate : 테이블과 엔티티 매핑 정보 비교해 차이 있으면 경고 남기고 실행하지 않는다
- none : 자동 생성 기능 사용 X

```java
@Entity
@Table(uniqueConstraints= {@UniqueConstraint(
	name = "NAME_AGE_UNIQUE"
	columnNames={"NAME","AGE"}
)})
```

유니크 제약조건 역시 지정 가능
( DDL 자동 생성에만 사용, 실행 로직에는 영향 X - 엔티티만 보고도 다양한 제약 조건 파악 가능 )
### Id

직접 할당(기본 키 직접 할당), 자동 생성(대리 키 사용 방식) 두 가지 방법 존재
#### 직접 할당
```java
@Id
private String id;

=========
Board board = new Board();
board.setId("...);
em.persist(board);
```
직접 할당
기본형,래퍼형(String,Date,BigDecimal,BigInteger) 가능
#### 자동 생성
##### IDENTITY

기본 키 생성을 DB에 위임하는 전략
-> DB에 값 저장 하고 나서야 기본 키 값을 구할 수 있음

- persist 호출 즉시, DB 에 전달한다 - 식별자를 그래야 알 수 있으므로
##### SEQUENCE

시퀸스는 유일한 값을 순서대로 생성하는 특별한 DB Object
```sql
CREATE TABLE BOARD (
	ID BIGINT NOT NULL PRIMARY KEY
	DATA VARCHAR(255)
)
CREATE SEQUENCE BOARD_SEQ START 1 INCREMENT BY 1;
```
해당 DDL은?
```java
@Entity
@SequenceGenerator(
	name = "BOARD_SEQ_GENERATOR"
	sequenceName = "BOARD_SEQ"
	initialValue = 1, allocationSize = 1)
public class Board{
	@Id
	@GeneratedValue(stragety = GeneratioNType.SEQUENCE,
					generator = "BOARD_SEQ_GENERATOR")
}
```
이 코드와 동일하다

allocationSize 는 시퀸스 한 번 호출에 증가하는 수 - 성능 최적화에 사용 ( default : 50 )
```java
ExecutorService executorService = Executors.newFixedThreadPool(2);  
  
executorService.submit(() -> {  
    TransactionStatus transactionStatus = transactionManager.getTransaction(new DefaultTransactionDefinition(TransactionDefinition.PROPAGATION_REQUIRES_NEW));  
    Customer customer1 = customerRepository.save(new Customer(null, "Jack", "Bauer"));  
    transactionManager.commit(transactionStatus);  
    assertThat(customer1.getId()).isEqualTo(1L);  
});  
  
executorService.submit(() -> {  
    TransactionStatus transactionStatus = transactionManager.getTransaction(new DefaultTransactionDefinition(TransactionDefinition.PROPAGATION_REQUIRES_NEW));  
    Customer customer2 = customerRepository.save(new Customer(null, "Joy", "Son"));  
    transactionManager.commit(transactionStatus);  
    assertThat(customer2.getId()).isEqualTo(51L);  
});
```

각 스레드마다 시퀸스 값을 할당 받는다
( 여러 JVM 이 동시 동작해도 기본 키 값 충돌하지 않는다 )
( 시퀸스 값이 많이 증가하고, 이런 상황이 부담스럽고 INSERT 성능이 중요하면 1도 OK )
##### TABLE
```java
@Entity
@TableGenerator(
	name = "BOARD_SEQ_GENERATOR"
	sequenceName = "BOARD_SEQ"
	initialValue = 1, allocationSize = 1)
public class Board {
	@Id
	@GeneratedValue(stragety = GeneratioNType.TABLE,
					generator = "BOARD_SEQ_GENERATOR")
}
```

테이블을 sequence 처럼 흉내 내는 것이므로 모든 DB에서 사용 가능

```sql
select
	tbl.next_val 
from
	board_seq tbl 
where
	tbl.BOARD=? for update

update
	board_seq 
set
	next_val=?  
where
	next_val=? 
	and BOARD=?
```

select-update 문이 발생한다!
##### AUTO

선택한 DB 의 방언에 따라 자동으로 선택한다
- DB를 변경해도 코드 수정할 필요가 없다
( Sequence,Table 일시 자동으로 생성해줌 )

---

- 지연 키 : 비즈니스 의미가 있는 키 - 주민등록번호,이메일
- 대리 키 : 비즈니스와 관련 없는 임의 만들어진 키 - auto_increment,sequence ...

키는 3가지 조건을 만족해야함
1. null 값을 허용하지 않는다
2. 유일해야 한다
3. 변해선 안 된다

> 지연 키 보다 대리 키를 사용하자
> ( 전화번호가 없어질 수도, 변할수도 있다, 주민등록번호 역시도 가능! )
> EX) 정부 정책 변화로, 주민등록번호를 저장할 수 없게 된 적 있음
> -> 이메일,주민등록번호는 필요 따라 Unique Index 를 설정하자

### 필드와 컬럼 매핑
#### Column

- 객체 필드 - 테이블 컬럼 매핑
	- name : 필드와 매핑할 컬럼 이름
	- nullable : null 값 허용 여부
		-> @Column(nullable=false) - varchar(255) not null
	- columnDefinition : 컬럼 정보 직접 줌
		-> @Column(columnDefinition = "varchar(100) default 'EMPTY'") - varchar(100) default 'EMPTY'

> @Column 을 생략한다면?
> int data; -> data integer not null
> 
> Integer data2 -> daeta2 integer
> 
> @Column
> int dat3; -> data3 integer

@Column 은 nullable=true 가 기본값!
-> 기본 타입에 @Column 사용시, nullable=false 를 지정하자
#### Enumerated
- EnumType.ORDINAL : enum 순서를 DB에 저장
- EnumType.STRING : enum 이름을 DB에 저장
-> 왠만하면 STRING 을 사용하자
( ordinal 은 Enum 이 추가되면 변동되듯이, 변화에 민감해진다 )

#### Temporal

Deprecated!
-> Java 에서 제공해주는 타입을 사용하자
( LocalDate,LocalTime ... )
#### Lob
```java
@Lob
private String lobString;
```
- CLOB : String, char`[]`
- BLOB : byte`[]`
타입에 따라 매핑
#### Transient
```java
@Transient
private Integer temp;
```

해당 값은 매핑 x
( DB에 저장하지 않고, 조회하지도 않음 - 어떤 값 보관하고 싶을 때 사용 )
#### Access

- 필드 접근 : 필드에 직접 접근, private 여도 OK
- 프로퍼티 접근 : 접근자(Getter) tkdyd
( Access 설정하지 않으면, @Id 를 기준으로 접근 방식 설정 )

근데 솔직히 프로퍼티 접근 해야할 필요성을 못 느끼겠음

