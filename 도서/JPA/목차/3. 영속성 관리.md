### 영속

영속성 컨텍스트가 관리하는 엔티티 - 영속 상태
`em.persist(member)` or `em.find()` 
- 식별자 값이 반드시 있어야 한다 ( `@Id` ) - 없으면 예외 발생

트랜잭션 커밋 순간 영속성 컨텍스트에 새로 저장된 엔티티 DB 반영
-> 플러쉬(flush)
#### 영속 엔티티의 동일성 보장

```java
Member a = em.find(Member.class,"member1");
Member b = em.find(Member.class,"member2");
```

1차 캐시에 있는 같은 엔티티 인스턴스 반환!
애초에 equals 를 정의하든 재정의 하지 않든 상관이 없음!
( 같은 객체를 가지고 오므로 당연히 동일! )
- 동일성 : 실제 인스턴스 같음, 참조 값 비교할시 동일하게 나온다. - 메모리 주소
- 동등성 : 실제 인스턴스는 다르나, 가지고 있는 값이 같다. - equals

EntityManager.clear 후에는 당연히 동일하지 않게 된다
#### 엔티티 등록

```java
transaction.begin();

em.persist(memberA);
em.persist(memberB);

transaction.commit();
```

트랜잭션 커밋 전에는 쓰기 지연 SQL 저장소에 저장
-> 트랜잭션 커밋 후에는 영속성 컨텍스트 flush!

=> 어떻게든 커밋 직전에만 SQL 전달하면 되므로! - 쓰기 지연 OK
#### 변경 감지
```java
Member member = em.find(Member.class, "memberA");

memberA.setAge(10);
```

JPA 로 엔티티 수정 때는 단순 엔티티 조회해 데이터만 변경하면 OK!
-> 엔티티 변경사항 반영하는 변경 감지 때문!
##### 스냅샷
엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태 복사해서 저장
-> 플러시 시점에 스냅샷과 엔티티 비교

1. 트랜잭션 커밋하면 엔티티 매니저 내부에서 먼저 flush 호출
2. 엔티티와 스냅샷 비교해 변경된 엔티티 찾음
3. 변경된 엔티티가 있으면 수정 쿼리 생성해 쓰기 지연 SQL 저장소 보관
4. 쓰기 지연 저장소 SQL을 DB에 보냄
5. DB 트랜잭션 커밋

---

- 변경 감지는 영속 상태 엔티티에만 적용 가능
- JPA 의 update 전략은 모든 필드를 업데이트

모든 필드 사용하면 DB 보내는 데이터 전송량은 증가하나
- 수정 쿼리가 항상 같음 ( 로딩 시점에 미리 생성하고 재사용 )
- DB에 동일한 쿼리 보내면, DB는 한 번 파싱된 쿼리 재사용!

```java
@Entity
@DynamicUpdate
@Table
public class Member
```
필드가 많거나, 저장 내용이 너무 크면 수정 데이터 사용해 동적 UPDATE SQL 생성해서 사용하자!
-> 수정된 데이터만 사용해서 동적으로 생성

( 데이터가 존재하는 필드만으로 삽입하는 `@DynamicInsert` 도 존재 )

> 컬럼이 대략 30개 이상일 시, 기본 방법보다 동적 수정이 빠르다고 함 - 이 역시도 상황을 고려해야함
#### 엔티티 삭제

```java
Customer customer = new Customer(null, "Jack", "Bauer");  
customerRepository.save(customer);  
customerRepository.delete(customer);
```
save 후 delete 시?
-> query 들이 날라가지 않는다! ( 쓰기 지연 SQL 저장소에 저장 -> save-delete 이므로 필요없다 판단 )
remove 호출 시, 영속성 컨텍스트에서 제거 - 재사용 하지말고, <span style="color:#00b0f0">GC 대상이 되도록 두자</span>
### 플러시

영속성 컨텍스트의 변경 내용을 DB 반영

1. em.flush() 직접 호출
2. 트랜잭션 커밋 시 플러시 자동 호출
-> 트랜잭션 커밋 전 플래시 호출해서 변경 내용을 DB에 반영해야함!
3. JPQL 쿼리(+Criteria) 실행 시 플러시 자동 호출
```java
em.persist(memberA);
em.persist(memberB);

//JPQL
query = em.createQuery("select m from Member m",Member.class);
```
persist 통해 영속 상태 만들었으나, DB 반영 X
JPQL 은 SQL 로 변환해 DB 로직 수행
-> 영속성 컨텍스트 flush 호출후 실행한다

