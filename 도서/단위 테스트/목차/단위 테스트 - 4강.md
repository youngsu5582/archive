### 좋은 단위 테스트의 4대 요소

- 회귀 방지
- 리팩토링 내성
- 빠른 피드백
- 유지 보수성

-> 어떤 자동화된 테스트 ( 단위 테스트 , 통합 테스트 , E2E ) 도 분석 가능

#### 회귀 방지

>회귀 : 코드를 수정한 후 ( 새 기능 출시 후 ) 기능이 의도한 대로 작동하지 않는 경우

이런 회귀는 매우 귀찮음 유발
-> 개발할 기능이 많을 수록 새로운 릴리스에서 기능이 하나라도 고장 날 가능성이 높으면 매우 최악!

=> 회귀에 대한 효과저인 보호책을 개발하는게 매우 중요

다음 사항들을 고려하자

- 테스트 중 실행되는 코드의 양

일반적으로 실행되는 코드 많을수록
테스트에서 회귀가 나타날 가능성이 높음 - 코드가 생성하는 결과가 유효한지도 역시 확인해야함

- 코드 복잡도
- 코드의 도메인 유의성

복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 보다 훨씬 더 중요하다
( 단순한 코드 테스트 하는 것은 가치가 거의 없다 - 짧고 , 비즈니스 로직을 많이 담고 있지도 않음 )

작성하지 않은 코드 ( 라이브러리 , 프레임워크 , 외부 시스템 ) 도 중요하다
-> 테스트가 해당 내용들도 테스트 범주에 포함해 의존성에 대한 검증이 올바른지 확인하자

#### 리팩토링 내성

테스트를 Fail로 바꾸지 않고 기본 애플리케이션 코드를 리팩토링 할 수 있는지 대한 척도

리팩토링시 아무 것도 고장이 나지 않았는데 , 테스트가 Fail 이 됐다면?
-> 거짓 양성! ( 실제 기능은 의도 대로 작동하지만 , 테스트는 실패를 나타내는 결과 )
=> 적을 수록 좋다

거짓 양성은 전체 테스트 스위트에 치명적 영향을 줄 수 있기 때문
-> 단위 테스트 목표인 프로젝트 성장을 지속 가능하게 하는 것에 어긋남

거짓 양성 빈번하면 테스트 스위트에 대한 신뢰 서서히 떨어지며 , 믿을 만한 안전망으로 인식 X
-> 신뢰가 부족해지면 리팩토링 줄여듬 ( 회귀 피하려고 코드 변경 최소한 )

> 양치기 소년은 왜 죽었는가?
##### 무엇이 거짓 양성의 원인인가?

거짓 양성의 수는 테스트 구성 방식과 직접적 관련이 있다

테스트 와 SUT 의 구현 세부 사항이 많이 결합될수록 허위 정보가 더 많이 생김
-> 세부 사항을 테스트에서 분리해 거짓 양성에 대한 가능성을 줄여나가자
=> 테스트가 최종 결과를 검증하는지 확인해야 함

즉 , 테스트가 실패하면 이야기 와 실제 애플리케이션 동작이 분리되어 실패하게 만들자

무엇이 잘못 됐는지 빨리 이해하게 도움이 된다
( 다른 실패는 중요한 것으로부터 주의를 돌리려는 소음일 뿐 )
##### 구현 세부 사항 대신 최종 결과를 목표로

테스트를 깨지지 않게 하고 리팩토링 내성을 높이려면
SUT 구현 세부 사항 과 테스트 간 결합도를 낮추어 나가야함

- 좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것 - 처리하기 까다로워짐
#### 첫 번째 특성 과 두 번째 특성 간 본질적 관계

둘 다 정반대 관점에서도 테스트 스위트 정확도에 기여

두 가지 특성은 시간이 흐려며 프로젝트에 영향을 다르게 미치는 경향이 있다
( 프로젝트 시작 직후에는 당연히 회귀 방지를 휼룡하게 갖춤 , 리팩토링 내성은 바로 필요하지 않음 )

##### 테스트 정확도 극대화

- 거짓 음성(2종 오류) : 기능이 고장이여도 테스트가 통과하는 경우
	-> 회귀 방지가 도움이 된다
- 거짓 양성(1종 오류) : 기능이 작동해도 테스트가 실패하는 경우
	-> 리팩토링 내성이 도움이 된다

두 내성은 테스트 스위트 정확도를 극대화 하는 것을 목표로 함

- 테스트가 버그 있음을 얼마나 잘 나타내는가
- 테스트가 버그 없음을 얼마나 잘 나타내는가

테스트 정확도 = 신호 ( 발견된 버그 수 ) / 소음 ( 허위 경보 발생 수 )

신호 증가 : 회귀를 더 잘 찾아내는 테스트로 개선
소음을 줄이는 것 : 허위 경보 발생시키지 않는 테스트로 개선

##### 거짓 양성 - 거짓 음성의 중요성 : 역학 관계

단기적으로는 거짓 양성도 거짓 음성 만큼 나쁘지 않음 ( 거짓 음성이 처음부터 나쁘다는 뜻 )

리팩토링이 바로 중요하지 않음! ( 초기엔 코드 정리 X , 기억 속 생생함 )
-> 시간이 흐를수록 코드 베이스는 나빠짐 ( 복잡하고 , 체계적이지 않게 된다 )
-> 정기적으로 리팩토링을 해야만 함 ( 새로운 기능에 드는 비용이 갈수록 커짐 )
=> 테스트에서 리팩토링 내성이 점점 더 중요해진다

( 회귀 방지는 결국 성장을 유지하는 데 도움을 줌 )

129 부터

