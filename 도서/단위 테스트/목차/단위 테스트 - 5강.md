#### 테스트 대역 유형

- 테스트 대역 : 모든 유형의 비운영용 가짜 의존성
목 과 스텁이라는 두 가지 유형으로 나뉨

- 목 : Mocking , Spy
외부로 나가는 상호 작용 모방 & 검사하는 데 도움 ( SUT 가 상태 변경 위한 의존성 호출 )
-> SMTP 서버는 외부 나가는 상호 작용 - 사이드 이펙트 O

- 스텁 : Stub , Dummy , Fake
내부 들어오는 상호 작용 모방 도움 ( SUT가 입력 데이터 얻기 위한 의존성 호출 )
-> DB 는 내부로 들어오는 상호 작용 - 사이드 이펙트 X 

다섯 가지의 차이점은 결국 미미한 구현 사항 차이

- 스파이는 목과 유사하나 , 목은 Mocking 프레임워크에 도움 받음
- 더미는 널 , 가짜 문자열 같은 단순 & 하드코딩 된 값 ( 메소드 매개변수 등에 사용 )
- 스텁은 더 정교함 ( 시나리오마다 다른 값을 반환하게 필요한 것을 갖춘 완벽한 의존성 )
- 페이크는 보통 아직 존재하지 않는 의존성을 대체하고자 구현

목은 SUT 와 의존성 간 상호 작용을 모방 & 검사
스텁은 모방만 함

#### 도구로서의 Mock VS 테스트 대역로서의 Mock

```java
var mock = new Mock<IEmailGateway>();
var sut = new Controller(mock.Object);

sut.greetUser("user@gmail.com");

mock.verify(x -> x.SendGreetingEmail("user@gmail.com"), Times.Once);
```

- Mock 클래스는 테스트 대역 만들 수 있는 도구로서의 Mock
- mock 인스턴스는 테스트 대역으로서의 Mock

```java
var stub = new Mock<IDatabase>();
stub.setup(x -> x.getNumberOfUsers()).returns(10);
var sut = new Controller(stub.Object);

Report report = sut.createReport();

assertEquals(10, report.numberOfUsers);
```

- stub 은 내부로 들어오는 상호 작용 , SUT에 입력 데이터 제공 호출 모방

도구 Mock 과 테스트 대역 mock 을 구분하자

##### 스텁으로 상호 작용을 검증하지 말자

스텁 으로 호출은 SUT가 생성하는 최종 결과가 아님! 
-> 취약한 테스트 야기하는 안티 패턴

```java
mock.verify(x -> x.SendGreetingEmail("user@gmail.com"));
```

해당 결과는 비즈니스 담당자가 시스템에 하길 원하는 값 -> 검증 해야 함!

```java
stub.setup(x -> x.getNumberOfUsers()).returns(10);
```

해당 내용은 데이터 수집 방법에 대한 내부 구현 세부 사항
-> 결과만 올바르다면 검증할 필요 X

```java
stub.verify(x -> x.getNumberOfUsers(),Times.Once);
```

최종 결과가 아닌 사항 검증하는 관행
-> 과잉 명세

#### 목과 스텁은 명령 - 조회에 어떻게 관련되어 있는가?

목 과 스텁은 명령 조회 분리 (CQS) 원칙과도 관련이 있음!

> CQS
> 모든 메소드는 명령 or 조회여야 하며
> 혼용 되어서는 안 된다!
> 명령 : 사이드 이펙트 일으킴 + 반환 값 X
> 조회 : 사이드 이펙트 X + 반환 값 O
> 
> 물론 , stack.pop 처럼 CQS 원칙을 따를 수 없는 것 역시 존재

명령을 대체하는 테스트 대엽은 Mock
조회를 대체하는 테스트 대역은 Stub

sendGreetingEmail 은 이메일을 보내는 사이드 이펙트 존재하는 <span style="color:#00b0f0">명령</span> 
getNumberOfUsers 는 값 반환하고 DB 상태 변경하지 않는 <span style="color:#fb3c3c">조회</span> 

### 식별할 수 있는 동작 과 구현 세부 사항

결국 최종 결과만을 검증하고 
구현 세부 사항 과 테스트를 가능한 떨어뜨리는게 핵심
( "어떻게" 가 아닌 "무엇" 에 중점을 둬야 함 )

#### 식별할 수 있 동작 != 공개 API

제품 코드는 2차원으로 분류 가능

- 공개 API or 비공개 API
- 식별할 수 있는 동작 or 구현 세부 사항

각 차원 범주는 서로 겹치지 않음
( 식별할 수 있는 동작이 public or private 둘다 가능 하다는 말 )

-> 클라이언트가 목표 달성하는 데 도움이 되는 연산을 노출 ( 계산 수행 or 사이드 이펙트 초래 or 둘다 )
-> 클라이언트가 목표 달성하는 데 도움이 되는 상태를 노출 ( 상태 : 시스템 의 현재 상태 )
( 구현 세부 사항은 두 가지 중 아무것도 하지 않음 )

이상적으로는 
- 공개 API 와 식별할 수 있는 동작 일치해야함
- 구현 세부 사항은 클라이언트 눈에 보이지 않는 비공개여야함
##### 구현 세부 사항 유출 : 연산 예
```java
public class UserController {
	public void renameUser(int userId,String newName) {
		User user = 디비_검색_아이디(userId);

		String normalizedName = user.normalizeName(newName);
		user.name = normalizedName;

		디비_저장(user);
	}
}
```
(UserController 가 클라이언트 코드 )
속성 과 메소드 둘다 공개

- 클라이언트가 목표 달성하는 데 도움이 되는 연산을 노출
- 클라이언트가 목표 달성하는 데 도움이 되는 상태를 노출

해당 두 가지를 속성하는 값은?
-> Name 속성

```java
public class User {
	private String normalizeName(String name) {
		String result = name.trim();

		if(result.length() > 50)
			return result.subString(0,50);
		return result;
	}
}

public void renameUser(int userId,String newName) {
		User user = 디비_검색_아이디(userId);
		user.name = newName;
		디비_저장(user);
}
```

식별할 수 있는 동작만 공개 , 구현 세부 사항은 비공개 API에 은닉
###### 잘 설계된 API + 캡슐화

캡슐화는 결국 불변성 위반 하는 모순 방지 조치

구현 세부 사항을 노출하면 불변성 위반 가져옴 -> 캡슐화 역시 제대로 유지 불가능

장기적으로 코드베이스 유지 보수에는 캡슐화가 중요 ( 복잡도 때문 )
-> 복잡해질수록 작업하기 더 어려워짐 + 개발 속도 느려짐 + 버그 수 증가
=> 캡슐화 만이 대처할 수 있는 실질적 방법

할 수 있는 것과 할 수 없는 것을 구분하는 것이 매우 중요함
-> 코드 변경 시 모순이 생기지 않게 많은 정보를 염두에 둬야 함
-> 프로그래밍 프로세스에 정신적 부담 증대
-> 실수할 가능성을 최대한 없애주는게 캡슐화를 올바르게 유지!
=> 지속적인 성장을 가능하게 해주는 것

- 구현 세부 사항을 숨기면 클라이언트 시야에서 클래스 내부 가릴 수 있으므로 내부 손상 위험이 적음
- 데이터 - 연산 결합시 해당 연산이 클래스 불변성 위반하지 않도록 할 수 있음
##### 구현 세부 사항 유출 : 상태 예

```java
public class MessageRenderer {
	public ReadOnlyList<IRenderer> subRenderers;

	public String render(Message message) {
		return ...
	}
}
```

멤버 변수가 public 일시 구현 세부 사항 유출
좋은 단위 테스트 와 잘 설계된 API 사이에는 본질적 관계 존재!
-> 세부 사항 비공개로 하면 테스트가 식별 동작 검증하는 것 외 다른 선택지 불가능
=> 리팩토링 내성 역시 자동으로 좋아짐!

|     | 식별할 수 있는 동작 | 구현 세부 사항 |
| :-- | :---------- | :------- |
| 공개  | 좋음          | 나쁨       |
| 비공개 | 해당 없음       | 좋음       |
5.3 부터 다시
