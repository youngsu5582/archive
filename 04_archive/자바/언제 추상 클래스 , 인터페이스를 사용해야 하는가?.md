---
tags: 자바
---
#### 인터페이스

상호 작용 방식을 명세
호출자는 구현에 대한 지식 없이도 원하는 기능을 수행할 수 있어야 함 - 일종의 계약 ( contract )

>자동차가 어떻게 움직이는지 세부 구현은 모르나 
>엑셀을 밟으면 앞으로 가고 브레이크를 밟으면 멈춘다는 약속을 통해 운전 가능

#### 추상 클래스

인터페이스와 유사
인스턴스 화 불가능 + 구현 포함하거나 포함하지 않은 메소드 모두 가질 수 있다
- 필드를 가질 수 있다 ( 모든 접근 제어자 가능 - static , final , protected/public/private )

extends 는 단일 , implements 는 여러개

---

추상 클래스는 <span style="color:#fb3c3c">코드 재사용</span> 을 위해 사용
-> 하위 클래스는 추상 클래스를 상속받아 속성 & 메소드 사용 가능 - 동일 코드 재작성 X
- 추상 메소드 구현을 컴파일 시점에서 확인 가능
- 추상 클래스 객체 생성을 막을 수 있다

인터페이스는 <span style="color:#00b0f0">디커플링</span> 을 위해 사용
-> 일련의 프로토콜 or 계약을 추상화
호출자는 인터페이스에만 주의를 기울이면 OK - 구현 방식 자체는 몰라도 된다

인터페이스를 통해 구현 분리 + 코드 결합도 줄이고 확장성을 높일 수 있다

추상 클래스는 is-a 관계 ( 요리사는 사람 -> Is-a 관계 )
-> 코드 재사용 문제를 해결할 때 사용
- 상향식 설계 방식 ( 하위 클래스 코드 반복한 다음 상위 클래스 추상화 )

인터페이스는 has-a 관계
-> 코드 재사용이 아닌 추상화 문제를 해결하려며 인터페이스 사용
- 하향식 설계 방식 ( 먼저 인터페이스를 설계 후 특정 구현 고려 )

#### 왜 상속 대신 합성을 사용해야 하는가?

일단 상속의 단점?

##### 1. 캡슐화가 깨지고 결합도가 높아짐

> 결합도 : 하나의 모듈이 다른 모듈에 대해 얼마나 많은 지식을 가지고 있는지의 정도
> -> 추상화에 의존해 다른 객체 대한 결합도는 최소화 하고 응집도는 최대화 해 변경 가능성을 최소화 해야 한다

부모 클래스 & 자식 클래스 의 관계는 컴파일 시점에 결정 -> 구현에 의존 된다
자식 클래스는 부모 클래스의 코드를 직접 호출 가능하므로 , 부모 클래스 내부 구조 까지 알고 있어야 함
-> super 를 사용하면 부모 구현 역시 노출되어 캡슐화 약해짐 + 자식 클래스 역시 강하게 결합된다
##### 2. 유연성 & 확장성이 떨어짐

강하게 결합되므로 , 유연성 & 확장성이 떨어지는건 당연

상위 클래스에 새로운 메소드를 추가 해야 한다면?
( count 멤버 변수 와 getFoodCount 를 추가해야 하면? )

하위 클래스 까지 전부 반영을 해야 한다 - 하위 클래스 생성자

=> 변경에 대한 범위가 매우 커진다 ( 자식 클래스 마다 메소드 구현이 달라진다면?? BOOM )
##### 3. 클래스 폭발 문제 발생할 수 있음

상속을 남용하면 필요 이상 많은 클래스 추가 증가하는 문제 발생 가능하다!

강하게 결합되는 근본적 한계 때문
-> 자식 - 부모 클래스 간 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합 수 만큼 새로운 클래스 추가...
##### 4. 다중 상속에 의한 문제

자바는 다중 상속 허용 X
상속이 필요한 클래스가 이미 다른 클래스 상속중일 시 문제 발생!
-> 상속은 최대한 지양해서 열어두는게 좋은거 같다
##### 5. 합성을 사용하기

상속은 컴파일 시점에 강하게 결합
<-> 합성은 효과적으로 캡슐화 가능 - 의존하는 객체를 교체하는 것이 비교적 쉬우므로 설계에 유연해짐
- 합성은 메시지를 통해 느슨하게 결합이 된다

```java
public abstract class Food {
	public int getFoodCount() {
		return next == null ? 1 : 1 + next.getFoodCount();
	}
}
```

Food 객체를 컴파일 타임에 의존 X - 추상화
-> 런타임 의존성을 구상 가능하다!

---
#### 상속을 사용해야 하는 경우는?

- 타입 계층을 구현하는 것
- 코드를 재사용 하는 것

2번을 위해서라면 제약이 많으므로 조심해서 사용을 해야 한다
##### 부모 와 자식 클래스가 Is-A 관계인 경우

어휘적으로 타입 S 는 타입 T 이다 를 표현 가능할 떄 상속을 이용 해야 함 ( 펭귄은 새이다 )
##### 행동 호환성이 만족하는 경우

>행동 호환성 : 클라이언트 입장에서 부모 클래스 와 자식 클래스의 차이점을 몰라야 함
>-> 부모 클래스 타입으로 자식 클래스를 사용해도 무방함을 나타낸다

`새는 날 수 있다`
펭귄은 날 수 있나?
=> findBird 를 통해 펭귄이 나온다면 bird.fly 를 할 수 없다!
```java
public class Bird {

}

public class FlyingBird extends Bird {
    public void fly() { ... }
}

public class Penguin extends Bird {

}
```

이렇게 행동 호환성을 분리해줘야 한다

=> is-A 관계에서 그칠게 아닌 행동호환성 까지 고려를 해줘야 한다!

#### 결론

상속이 코드를 쉽게 재사용 가능하게 해준다

관계가 추가될 수록 시스템 결합도가 높아지고 , 변경이 어려워 지며 , 캡슐화가 깨진다

상속을 반드시 사용해야 한다면 , 유사 두 메소드를 추출해 동일 형태 +
자식 클래스 코드를 부모로 옮기자

=> 가급적이면 합성을 사용하자

상속은 다형성 활용을 위한 서브타입 계층을 구축해나가는 것
