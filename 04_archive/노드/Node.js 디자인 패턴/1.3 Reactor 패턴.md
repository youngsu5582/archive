---
tags:
  - 노드
도서명: Node.js 디자인 패턴 바이블
저자명: Mario Casciaro,Luciano Mammino
aliases:
  - Node.js Design Patterns
---
## Node.js 철학
------
### I/O 는 속도가 느리다

I/O (입출력) 은 컴퓨터의 기본 동작중 가장 느립니다.

RAM 에 액세스 하는데 걸리는 시간은 나노 초 (10E-9) , 
디스크 또는 네트워크 데이터에 액세스 하는데 걸리는 시간은 밀리초 (10E-3) 입니다.

RAM 은 GB/s 단위로 일관되게 유지되나 , 디스크 및 네트워크는 MB/s 부터 GB/s 까지 다양합니다.

I/O 는 일반적으로 CPU 측면에서 비용이 많이 들지는 않나 ,
요청 보낸 순간 부터 작업 완료되는 순간 까지 지연이 동반됩니다!
-> 특히 , 기술적인 면에 의존이 아닌 , 실제 사람 입력에도 의존합니다!
( 디스크 나 네트워크 보다 , 훨씬 더 느리게 진행이 될 수도 있습니다 )

### 블로킹 I/O

가장 전통적인 프로그래밍입니다.
I/O 요청에 해당하는 함수 호출이 작업 완료될 때 까지 스레드 실행이 차단됩니다.
```javascript
data = socket.read();

print(data);
```
- 해당 코드는 단순한 의사 코드입니다 ! ( 실제 작동 X )
- 데이터를 사용할 수 있을 때까지 스레드가 블록됩니다.

블로킹 I/O 를 사용해 구현한 웹 서버는 동일 스레드에서 여러 연결 처리할 수 없다는 것이 당연합니다
( 연결 하면 블록 되므로 다른 연결 처리 차단 )
=> 각각 처리 연결에 대해 새로운 스레드나 프로세스를 시작 해야만 합니다.

만약 , 모든 유형의 I/O 가 요청 처리를 차단한다고 생각하면,
매우 많은 스레드가 결과 기다리기 위해 차단되는지 알 수 있습니다.
=> 이는 , 메모리를 소비하고 Context Switching 을 유발하므로 ,
각 연결에 대해 대부분 시간 사용하지 않으며 장시간 실행되는 스레드를 사용하는 건 최상의 절충안은 아닙니다!☠️

### 논 블로킹 I/O

대부분의 최신 운영체제는 논 블로킹 I/O 를 따릅니다.
해당 모드에서 시스템 호출은 데이터가 읽히거나/쓰여질 때 까지 기다리지 않고 , 항상 즉시 반환됩니다.
-> 호출 순간에 결과 사용할 수 없는 경우 , 함수는 단순히 미리 정의된 상수를 반환해서 데이터가 없음을 알려줍니다

예를 들어 , Unix OS 에서 fcntl() 함수는 , 기존 FD ( File Descriptor )를 조작해
운영 모드를 논 블로킹으로 변경하는데 사용합니다.
-> 자원이 논 블로킹 모드에 있으면 , 자원에 읽을 준비가 된 데이터가 없을 시 
모든 읽기 조작은 EAGAIN 을 반환해 실패를 알립니다.

#### busy-waiting

논 블로킹 I/O 중 가장 기본적인 패턴입니다
실제 데이터가 반환될 때 까지 루프 내 리소스를 계속 폴링 하는 것입니다.
```javascript
resources = [socketA, socketB, pipeA];
while(!resource.isEmpty()){
	for ( i=0;i<resources.length;i++){
		resource = resources[i];
	let data =resource.read();
	if(data ===NO_DATA_AVAILABLE)
		continue;	
	if(data===RESOURCE_CLOSED)
		resources.remove(i);
	else
		consumeData(data);
	}
	
}
```

- 해당 기술로 , 동일 스레드에서 서로 다른 리소스를 처리할 수 있습니다.
-> 하지만 , 매우 비효율 적인걸 알 수 있습니다!
루프는 사용할 수 없는 리소스를 반복하며 , CPU를 계소 사용합니다!! ⚠️

#### 이벤트 디멀티플렉싱

1. 감시된 일련의 리소스 들로부터 들어오는 I/O 이벤트 수집
2. 큐에 넣고 처리할 수 있는 새 이벤트가 있을 때까지 차단
```javascript
socketA, pipeB;
watchedList.add(socketA,FOR_READ);  // [1]
watchedList.add(pipeB,FOR_READ);
while(events = demultiplexar.watch(watchedList)){  // [2]
	foreach(event in envets){  // [3]
		data = event.resource().read();
		if (data===RESOURCE_CLOSED)
			demultiplexar.unwatch(event.resource);
		else
			consumeData(data);
	}
}
```
1. 데이터 구조에 리소스 추가 ( 인스턴스를 특정 작업 - read 과 연결 )
2. 이벤트 통시자에 감시할 리소스 그룹 설정
	1. 호출들은 동기식
	2. 읽을 준비가 될 때까지 차단
		( 차단 되는 경우 , 호출로부터 복귀해 새로운 일련 이벤트 처리 가능! )
3. 이벤트 디 멀티 플렉서에 의해 반환된 각 이벤트 처리
	- 각 이벤트와 관련된 리소스는 읽이 작업 위한 준비가 되어 있음
	- 차단되지 않는 상황이라는 것을 보증
4. 모든 이벤트 처리후에는 , 다시 디멀티플렉서에서 처리 가능 이벤트 발생 떄 까지 차단 - Event Loop


해당 패턴을 사용하면 , Busy-waiting 기술 사용하지 않고도 단일 스레드 내
여러 I/O 작업을 처리할 수 있습니다

작업을 여러 스레드로 분산하지 않고 , 시간에 따라 분산합니다
	+ 하나의 스레드만 가진다는 것은 또한 동기화 걱정이 없는 동시성 전략을 사용할 수 있습니다!

### Reactor 패턴 소개

핸들러는 이벤트가 생성되어 이벤트 루프에 의해 처리되는 즉시 호출합니다.

![500](https://i.imgur.com/pz8fPJp.png)


1. 어플리케이션이 이벤트 디멀티플렉서에 요청 전달하여 새로운 I/O 작업 생성
	- 처리 완료될 떄 호출될 핸들러도 같이 지정합니다 ( callback 함수 )
	- 새 요청 전달하는 것은 논 블로킹 호출
	- 즉시 어플리케이션에 제어 반환
2. I/O 작업들이 완료되면 , 디멀티플렉서가 새 이벤트를 이벤트 큐에 집어 넣습니다.
3. 이벤트 루프가 이벤트 큐 항목들에 대해 반복합니다.
4. 각 이벤트 대해 관련된 핸들러가 호출됩니다.
5. 핸들러는 실행 완료되면 , 이벤트 루프에 제어권을 반환합니다 ( a )
	실행 중 , 새로운 비동기 동작 요청되어 이벤트 디멀티플렉서에 삽입될 수도 있습니다.
6. 이벤트 큐 내 모든 항목 처리시 , 루프는 이벤트 디 멀티플렉서에서 블록 되고 , 
	처리 가능 새 이벤트가 있을때 과정이 다시 트리거 됩니다

- 이벤트 멀티플렉서에서 I/O 작업을 기다리고 있는것을 알 수 있습니다!
- 이벤트 루프는 지정된 핸들러들을 호출하는 역활입니다

즉 , Reactor 패턴은 일련 관찰 대상 리소스에서 새 이벤트를 사용할 수 있을 때까지
차단 후 I/O 를 처리한 다음 , 각 이벤트를 관련 핸들러로 전달함으로써 반응합니다!


### Node.js의 논 블로킹 엔진 libuv

각 운영체제에는 이벤트 디 멀티플렉서에 대한 자체 인터페이스가 있습니다.
	- Linux : epoll
	- MacOS : kqueue
	- Window : I/O Completion

하지만 동일 OS 내에서도 리소스 유형에 따라 다르게 작동할 수 있으며 ,
이러한 불일치들 때문에 더 높은 수준 추상화를 필요로 합니다.

그렇기에 , Node.js 코어 팀은 libuv 라는 C 라이브러리를 만든 이유입니다.
libuv 라이브러리 때문에 , 주요 플랫폼과 호환되며,
서로 다른 유형 리소스들이 논 블로킹 동작을 표준화 할 수 있습니다.

- libuv 는 Node.js 의 하위 수준의 I/O 엔진을 나타냅니다.
- Reactor 패턴을 구현하므로 , 
	이벤트 루프 만들고 & 이벤트 큐 관리 & 비동기 입출력 작업 실행하는 API들 제공합니다.

### Node.js 를 위한 구조

리액터 패턴과 libuv 가 기본 요소이지만 ,
플랫폼을 구축하기 위해선 세 가지 구성 요소가 필요합니다.

- libuv 와 기타 낮은 수준의 기능들을 JavScript 에 랩핑하고 , 사용 가능하게 해주는 Binding Set
- V8 , Chrome 브라우저 용으로 개발한 JavaScript 엔진
	( Node.js 가 매우 빠르고 효율적인 이유 , V8은 혁신적 설계와 효율적 메모리 관리를 가능하게 해줍니다 )
- 상위 수준 Node.js API 구현하고 있는 코어 JavaScript 라이브러리

## 결론

다른 기술을 사용하는 ( 특히나 , 자바 ) 개발자들의 경우 , 이러한 원칙이 익숙하지 않은 것처럼 보일 수 있습니다.
경험에서 조금이라도 익숙한 패턴을 찾으려고 할 수도 있으나 , 필요한건 사고의 전환입니다!

리액터 패턴으로 인해 , 스레드와 경쟁 조건에 대해 걱정할 필요가 없어졌습니다.
모듈 패턴 과 단순성 & 최소화 원리는 재사용 가능성 , 유지 보수 용이 등 새로운 방식의 시나리오를 이끌었습니다.

또한 , ES2015 도입으로 더 흥미롭게 되었으며 , 표현 구문으로 모든 이점을 수용할 수 있는 새로운 장이 열렸습니다.
