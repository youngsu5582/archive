---
tags: 리팩토링
---
HTTP API 성숙도 모델

- 레벨 0 : 하나의 URI 정의, 모든 작업은 해당 URI 로 POST 요청
- 레벨 1 : 개밸 리소스 대한 별도 URI
- 레벨 2 : HTTP 메소드 사용해 리소스 대한 작업 정의
- 레벨 3 : 하이퍼미디어 (HATEOAS) 사용

> HATEOAS : Hypermidia As The Engine Of Application State
> 해당 데이터와 관련된 URI 를 응답에 포함하여 반환

대부분은 레벨2에서 그침 ( 모든 응답을 반환해주지 않으므로 )

결국 이런 성숙도는
제공해야 하는 HTTP 서비스의 종류에 대해 생각하고 이 서비스와 상호 작용하고자 하는 사람들의 기대치를 설정하는 데 도움을 준다.
### 기본 원칙

모든 API 는 직관적이어야 한다.
-> URI 만 봐도 무엇을 하는지 상세 스팩을 보지 않아도 알 수 있어야한다.

리소스는 테이블과 1:1 매칭 대상이 아니다.
-> API 는 리소스 중심 디자인 ( 리소스 : 클라이언트에서 접근할 수 있는 모든 종류 객체 or 데이터 등등 )

Stateless API 를 구성한다.
-> 요청 간 일시적 상태 정보를 유지하는 것은 불가능 + 불가능하게 구현해야 한다.
( 요청은 독립적이여야 하므로 요청 순서가 정해져있으면 안된다 )

---

### 클린 패턴
#### URI 에 API를 표기

```
api.example.com/v1/xxx - 별도 백엔드 API 서버로 분리시
www.example.com/api/v1/xxx - 단일 프로젝트가 프론트 화면, 백엔드 API 모두 다룰시
```

API 는 결국 애플리케이션 개발자들이 관리하는것이다.
#### URI 에 버전 표기

```
api.example.com/v1/orders/{orderId} 
www.example.com/api/v1/orders/{orderId}
```

- 명확성 : 버전이 URI에 명시되어 있으므로 직관적 이해 가능
- 버전 간 호환성 : 동일한 API의 여러 버전 공존 가능 ( 구 버전 사용자에게 영향 방지 가능 )
- 캐싱 용이성 : URI 자체가 독립적 관리, 캐싱 전략 쉽게 적용 가능  ( 각 버전마다 별도 전략 적용 )

파라미터와 헤더에 표기를 할 수 있으나, 왠만하면 경로에 표시하자

`api.example.com/v1/orders/{orderId}` ->  `www.example.com/api/v1/orders/{orderId}`

api 를 먼저 -> 버전을 다음
#### Path에 리소스 ID는 가능한 하나만 사용하자

```
/v1/orders/{orderId} - 특정 주문 조회
/v1/orders/{orderId}/courses - 특정 주문의 모든 강의 조회
```

`/v1/orders/{orderId}/courses/{courseId} - 특정 주문의 특정 강의 조회`
클라이언트가 여러 관계 수준을 탐색하는 URI 를 제공할 수 있으나

복잡성으로 인해서 오래 유지하기 어려우며 관계가 변하면 유연성이 떨어지게 된다.
특히, 리소스의 조회는 유니크한 기준값으로 조회를 해야만 한다.

하위 리소스 조회에 상위 리소스 ID가 필요하다면 유니크 하지 않음

왠만하면 리소스/리소스ID/하위 리소스 정도로만 구성을 하자
#### URI 는 케밥 케이스

왠만하면 `-`을 포함해서 구분하자

- camelCase 를 사용하지 않는다
- snake_case 를 사용하지 않는다
- 공백을 포함하지 않는다
- 특수 문자를 포함하지 않는다

>다만, 여전히 SEO를 전문적으로 하는 분들의 의견은 - 가 훨씬 더 효과적이라고 한다.
>라는 내용도 존재
#### Parameter, Body 는 카멜케이스

`www.example.com/reviews?userId=`

JSON 페이로드와 일관된 명명 규칙 유지 가능
#### 테이블이 아닌 리소스가 중심

주문 리소스는 내부적으로는 여러 테이블로 구현될 수 있음
하지만, 클라이언트에서는 단일 엔티티로 표시

HTTP API 의 목적은 Entity 및 해당 Entity 에서 애플리케이션이 수행할 수 있는 작업을 모델링
-> 필요하면 DB와 HTTP API 사이 매핑 계층을 도입하자!
#### 리소스는 복수형으로

대부분의 API는 리소스 그룹에서 특정 리로스 ID 통해 작업 진행
-> `www.example.com/reviews/${reviewId}`

RESTful 디자인 패턴의 일관성&예측 가능성을 높여준다.
#### URI 은 제공하는 정보에 집중

같은 리소스를 조회하나, 사용자 유형에 따라 다르게 하려면?

```
GET /users/${userId}/summary // 일반 유저 조회 
GET /users//${userId}/detail // 관리자 유저 조회
```

어떤 결과를 줄 수 있는 API인지 URI에 표현되어야 한다.

`GET /users/${userId}/by-admin`
-> API를 재사용할 여지를 제한시킨다.

동일 리소스 권한에 따라 서로 다른 형태 Response 가 필요할 경우 해당 API 가 제공하는 정보에 집중을 해서 표현하자
#### 복잡한 행위에는 동사를 URI 에 포함하자

CRUD 외 다양한 도메인 행위를 표현하기 위해 URI에 동사를 포함시키는 것 역시 충분히 타당하다.

- 주문을 삭제한다
- 주문을 취소한다

는 엄연히 다른 행위
`POST /orders/{orderId}/cancel` -> /리소스/{리소스 ID}/행위 형식으로 작성하자
#### 일관성 유지하기

일관된 용어를 지키자
내역을 `history` , `record` 등으로 다양하게 사용하면
일관성이 떨어지고, 처음 볼 시 사람마다 서로 다르게 해석이 가능해진다.

