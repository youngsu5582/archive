---
tags:
  - 데브옵스
도서명: 자바 개발자를 위한 데브옵스 툴
저자명: 스티븐 친,멜리사 맥케이,바루크 사도구르스키
---
> 잘 작동하는 복잡한 시슽메은 잘 작동하는 간단한 시스템으로부터 진화한다. - 존 갈

프로덕션에 배포되는 결과물 속속히 파악할 수 있는 통일된 시스템이 필요하다.
-> 진실(truth) 시스템

그리고, 진실 시스템은 소스 코드 관리 시스템에서 출발

- 협업 : 각자 작업 서로 충돌하는 경우 생기나, 이러한 생산성 저하 방지 가능
- 버전 관리 : 어떤 코드가 프로덕션 배포됐는지, 고객에게 릴리스 됐는지 식별 가능
- 히스토리 : 모든 버전이 발생 순서와 함께 기록, 과거 되돌린 버전 선정&변경 사항 식별 가능
- 속성 : 파일 변경 주체에 대한 기록 남음, 특정 파일 소유권&접근 도메인 식별 및 변경 위험성 평가
- 의존성 : 프로젝트 메타데이터 식별 근거 활용 가능
- 품질 : 피어 리뷰 쉽게 진행 가능, 리뷰 통해 변경 사항 공유&합의 절차 가짐

### 소스 코드 관리 세대 변화

> SCM : Source Code Management , 소스 코드 관리

#### 1세대

파일을 잠그는 방식으로 협업 지원

SCCS ( Source Code Control System ) , RCS ( Revision Controler System ) 는 파일 편질할때 먼저 파일 잠금
-> 파일 수정하기 위해선 잠금 상태 해체되어 있어야 함
( 파일 변경시 충돌 발생 가능성 원천적 차단 )

단점
- 같은 파일 편집하려면 다른 개발자 완료까지 대기 ( 생산성 저해, 동시성 제한 )
- 파일 간 충돌 문제 해결 불가능 ( 각기 다른 파일 수정해도, 두 파일 상호 의존적이면 변경 사항이 서로 충돌 )
#### 2세대

1세대 비해 상당히 개선 + 파일을 잠그지 않음 ( 동시 파일 수정해도 접근 차단 X )
-> 충돌 가능성 있어도 병합 단계에서 해결
( diif 알고리즘으로 파일 분석후 충돌 지점 발견하면 해결하도록 제시 )
#### 3세대

DVCS ( Distributed Version Control System ) - EX) Git
모든 개발자가 Repository 전체의 온전한 복사본&히스토리를 로컬에 보유
( 체크아웃 -> 파일 변경 -> 체크인 과정은 2세대 시스템과 같음 , 다른 개발자와 통합하는 과정이 다름 )

피어 투 피어 방식으로 동기화

장점
- 전적 오프라인 작업 : 로컬에 있으므로, 네트워크 연결 안해도 체크인&체크아웃&브랜치 관리 등 가능
- 단일 장애점 부재 : 모든 개발자 컴퓨터에 사본 생성하므로, 중복도가 높음
- 로컬 작업 속도 향상 : 로컬 시스템에서 이루어지므로, 속도 빠르며 네트워크&서버 부하 받지 않음
- 제어의 탈중앙화 : 코드 동기화시 전체 Repository 복사
	-> 오픈 소스 프로젝트가 중단되거나 방향성을 잃어도 독자적 작업 가능

단점
- Repository 초기 동기화 속도 저하 : 최초 동기화 할때 전체 히스토리 복사되므로 시간 더 걸림
- 스토리지 증가 : 모든 사람이 히스토리 복사본 보유 ( 디스크 용량 매우 많이 필요 )
### Git Command
#### 체인지셋 관리
- add : 버전 관리에 파일 리비전 추가 (파일 추적 X, 변경마다 실행 해야 함 )
- mv : 파일/디렉토리 이름 바꾸거나 경로 이동할때 사용
- restor : 파일 삭제 or 잘못 수정 시 Index 로부터 파일 복원
- rm : 파일/디렉토리 제거 + 다음 커밋 버전 관리 레코드도 업데이트
#### 히스토리 관리
- branch : 로컬 리포지토리의 모든 브랜치 나열
- commit : 작업 변경 사항 로컬 리포지터리에 저장 ( 실행하려면 먼저 변경 파일 내역 등록 )
- merge : 지정된 커밋들의 변경 내용 가져와 현재 브렌치에 합침
	 현재 브랜치의 자손이라면 `패스트 포워드` 방식으로 히스토리 순차 결합
	 ( 그렇지 않으면 머지 히스토리 생성되며 충돌 발생 여부 알려줌 - git pull 명령시 내부적 실행 )
- rebase : 현재 브랜치 커밋을 upstream 브랜치에 재현
- reset : HEAD 를 이전 상태로 복원 ( 원격 push 됐다면 upstream repository 에 문제 일으킬 가능성 존재 )
- switch : 작업 사본 브랜치 전환 ( 3방향 머지 발생 가능 - 미리 변경 사항 커밋하거나 stash 명령으로 저장하는 편이 좋음 )
- tag : 커밋에 태그 지정, 이메일 주소로 PGP 키 생성해 태그나 커밋에 서명 ( 고유성 지니어 한번 푸시할 시, 재사용 변경 X )
- log : 커밋 로그 텍스트 형식 출력
#### 협업 관리
- fetch : 원격 리포지터리로 히스토리를 가져오되, 로컬 커밋과 머지 X
- pull : git fetch 와 git merge FETCH_HEAD 를 연이어 실행한것과 동일 ( 충돌 발생 경우 있으며 해소해야 pull 완료 )
- push : 로컬 리포지토리에서 원격 리포지터리로 변경 사항 전송

### Git 협업 패턴
#### Git Flow

이른 시기 등장한 모델
- 통상적 프로젝트 사용하기에 필요 이상 복잡한 면도 존재
- develop(개발 통합용) 와 master(최종 릴리스용) 라는 2개 장기 지속 브랜치

- 개발 브랜치 : feat 단위
- 머지 전략 : 패스트포워드 X
- 히스토리 리베이스 : 리베이스 X
- 릴리스 전략 : 릴리스 브랜치 분리

feat 브랜치에서 코딩 완료시 -> develop 브랜치로 통합
릴리스가 결정되면  릴리스용 브랜치 새로 생성 -> 신기능 안정화 + 버그 픽스&코드베이스 패치 안정화 -> release 브랜치 통합 ( 릴리스 태그 지정 )

특성상 복잡한 머지 이력 생성되는 경향
( 모든 통합이 커밋 통해 이루어지므로 - 패스트포워드&리베이스 사용하므로 )

=> 여러 릴리스 병렬 진행하는 프로젝트에 적합
#### Github Flow

깃플로우를 단순화시킨 형태
지속적 웹 개발 릴리스에 발생하는 일반 사례 다루기도 편함

- 개발 브랜치 : feat 단위
- 머지 전략 : 패스트포워드 X
- 히스토리 리베이스 : 리베이스 X
- 릴리스 전략 : 별도 릴리스 브랜치 X

정말 단순하게 지향
master 브랜치가 기본 코드라인 & 릴리스 브랜치 역활까지 담당

모두 단기 브랜치에서 작업 -> 코드 테스트&리뷰 완료 -> 마스터 통합

=> 각종 툴을 활용하기 좋은 무대 ( 브랜치 전략 단순, 워크플로우가 일직선 형태, 복잡한 인수 X )
- 최신 릴리스만 존재하는 애플리케이션에 적합
#### Gitlab Flow

깃헙 플로우의 확장판
핵심 원칙은 같음

- 개발 브랜치 : feat 단위
- 머지 전략 : 개방형
- 히스토리 리베이스 : 리베이스 X
- 릴리스 전략 : 별도 릴리스 브랜치 X

릴리스 브랜치의 유무가 차이점
( 깃헙 프로젝트 수준으로 CD 를 실행한 팀이 별로 없다는 인식에서 발생 )

보통 릴리스 브랜치는 프로덕션에 코드 push 전 안정화 작업에 진행하는 용도로 사용
-> 깃랩은 마스터에 패치 직접 반영 & 체리픽으로 적용하는 방식 권장
- rebase 와 squash 로 히스토리 정리하는 개념 역시 큰 차이점
#### One Flow & 트렁크 기반 개발

는 불필요하다 생각해서 생략
### 마치며

빌드,릴리스,배포의 고속화는 견고한 데브옵스 근간!


